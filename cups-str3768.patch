diff -up cups-1.4.2/cups/auth.c.str3768 cups-1.4.2/cups/auth.c
--- cups-1.4.2/cups/auth.c.str3768	2014-03-06 12:10:58.682659974 +0000
+++ cups-1.4.2/cups/auth.c	2014-03-06 12:17:15.580771878 +0000
@@ -3,7 +3,7 @@
  *
  *   Authentication functions for the Common UNIX Printing System (CUPS).
  *
- *   Copyright 2007-2009 by Apple Inc.
+ *   Copyright 2007-2011 by Apple Inc.
  *   Copyright 1997-2007 by Easy Software Products.
  *
  *   This file contains Kerberos support code, copyright 2006 by
@@ -143,7 +143,8 @@ cupsDoAuthentication(
   */
 
   if ((http->digest_tries > 1 || !http->userpass[0]) &&
-      strncmp(http->fields[HTTP_FIELD_WWW_AUTHENTICATE], "Negotiate", 9))
+      (!strncmp(http->fields[HTTP_FIELD_WWW_AUTHENTICATE], "Basic", 5) ||
+       !strncmp(http->fields[HTTP_FIELD_WWW_AUTHENTICATE], "Digest", 6)))
   {
    /*
     * Nope - get a new password from the user...
@@ -194,171 +195,22 @@ cupsDoAuthentication(
   * Got a password; encode it for the server...
   */
 
+#ifdef HAVE_GSSAPI
   if (!strncmp(http->fields[HTTP_FIELD_WWW_AUTHENTICATE], "Negotiate", 9))
   {
-#ifdef HAVE_GSSAPI
    /*
     * Kerberos authentication...
     */
 
-    OM_uint32		minor_status,	/* Minor status code */
-			major_status;	/* Major status code */
-    gss_buffer_desc	output_token = GSS_C_EMPTY_BUFFER,
-					/* Output token */
-			input_token = GSS_C_EMPTY_BUFFER;
-					/* Input token */
-    char		*gss_service_name;
-					/* GSS service name */
-#  ifdef USE_SPNEGO
-    const char		*authorization;
-					/* Pointer into Authorization string */
-#  endif /* USE_SPNEGO */
-
-
-#  ifdef __APPLE__
-   /*
-    * If the weak-linked GSSAPI/Kerberos library is not present, don't try
-    * to use it...
-    */
-
-    if (gss_init_sec_context == NULL)
-    {
-      DEBUG_puts("1cupsDoAuthentication: Weak-linked GSSAPI/Kerberos framework "
-                 "is not present");
-      http->status = HTTP_AUTHORIZATION_CANCELED;
-
-      return (-1);
-    }
-#  endif /* __APPLE__ */
-
-    if (http->gssname == GSS_C_NO_NAME)
-    {
-      if ((gss_service_name = getenv("CUPS_GSSSERVICENAME")) == NULL)
-	gss_service_name = CUPS_DEFAULT_GSSSERVICENAME;
-      else
-	DEBUG_puts("2cupsDoAuthentication: GSS service name set via "
-	           "environment variable");
-
-      http->gssname = cups_get_gssname(http, gss_service_name);
-    }
-
-#  ifdef USE_SPNEGO /* We don't implement SPNEGO just yet... */
-   /*
-    * Find the start of the Kerberos input token...
-    */
-
-    authorization = httpGetField(http, HTTP_FIELD_WWW_AUTHENTICATE);
-
-    authorization += 9;
-    while (*authorization && isspace(*authorization & 255))
-      authorization ++;
-
-    if (*authorization)
-    {
-     /*
-      * Decode the authorization string to get the input token...
-      */
-
-      int len = strlen(authorization);
-
-      input_token.value  = malloc(len);
-      input_token.value  = httpDecode64_2(input_token.value, &len,
-					  authorization);
-      input_token.length = len;
-
-#    ifdef DEBUG
-      {
-        char *ptr = (char *)input_token.value;
-	int left = len;
-
-        fputs("input_token=", stdout);
-	while (left > 0)
-	{
-	  if (*ptr < ' ')
-	    printf("\\%03o", *ptr & 255);
-	  else
-	    putchar(*ptr);
-	  ptr ++;
-	  left --;
-	}
-	putchar('\n');
-      }
-#    endif /* DEBUG */
-    }
-#  endif /* USE_SPNEGO */
-
-    if (http->gssctx != GSS_C_NO_CONTEXT)
+    if (_cupsSetNegotiateAuthString(http))
     {
-      gss_delete_sec_context(&minor_status, &http->gssctx, GSS_C_NO_BUFFER);
-      http->gssctx = GSS_C_NO_CONTEXT;
-    }
-
-    major_status  = gss_init_sec_context(&minor_status, GSS_C_NO_CREDENTIAL,
-					 &http->gssctx,
-					 http->gssname, http->gssmech,
-#ifdef GSS_C_DELEG_POLICY_FLAG
-					 GSS_C_DELEG_POLICY_FLAG |
-#endif /* GSS_C_DELEG_POLICY_FLAG */
-					 GSS_C_MUTUAL_FLAG | GSS_C_INTEG_FLAG,
-					 GSS_C_INDEFINITE,
-					 GSS_C_NO_CHANNEL_BINDINGS,
-					 &input_token, &http->gssmech,
-					 &output_token, NULL, NULL);
-
-    if (input_token.value)
-      free(input_token.value);
-
-    if (GSS_ERROR(major_status))
-    {
-      cups_gss_printf(major_status, minor_status,
-		      "cupsDoAuthentication: Unable to initialize security "
-		      "context");
       http->status = HTTP_AUTHORIZATION_CANCELED;
-
       return (-1);
     }
-
-    if (major_status == GSS_S_CONTINUE_NEEDED)
-      cups_gss_printf(major_status, minor_status,
-		      "cupsDoAuthentication: Continuation needed!");
-
-    if (output_token.length > 0 && output_token.length <= 65536)
-    {
-     /*
-      * Allocate the authorization string since Windows KDCs can have
-      * arbitrarily large credentials...
-      */
-
-      int authsize = 10 +				/* "Negotiate " */
-                     output_token.length * 4 / 3 + 1 +	/* Base64 */
-		     1;					/* nul */
-
-      httpSetAuthString(http, NULL, NULL);
-
-      if ((http->authstring = malloc(authsize)) == NULL)
-      {
-        http->authstring = http->_authstring;
-	authsize         = sizeof(http->_authstring);
-      }
-
-      strcpy(http->authstring, "Negotiate ");
-      httpEncode64_2(http->authstring + 10, authsize - 10, output_token.value,
-		     output_token.length);
- 
-      gss_release_buffer(&minor_status, &output_token);
-    }
-    else
-    {
-      DEBUG_printf(("1cupsDoAuthentication: Kerberos credentials too large - "
-                    "%d bytes!", (int)output_token.length));
-      http->status = HTTP_AUTHORIZATION_CANCELED;
-      gss_release_buffer(&minor_status, &output_token);
-
-      return (-1);
-    }
-#endif /* HAVE_GSSAPI */
   }
-  else if (strncmp(http->fields[HTTP_FIELD_WWW_AUTHENTICATE], "Digest", 6))
+  else
+#endif /* HAVE_GSSAPI */
+  if (!strncmp(http->fields[HTTP_FIELD_WWW_AUTHENTICATE], "Basic", 5))
   {
    /*
     * Basic authentication...
@@ -371,7 +223,7 @@ cupsDoAuthentication(
                    (int)strlen(http->userpass));
     httpSetAuthString(http, "Basic", encode);
   }
-  else
+  else if (!strncmp(http->fields[HTTP_FIELD_WWW_AUTHENTICATE], "Digest", 6))
   {
    /*
     * Digest authentication...
@@ -391,6 +243,13 @@ cupsDoAuthentication(
 	     "response=\"%s\"", cupsUser(), realm, nonce, resource, encode);
     httpSetAuthString(http, "Digest", digest);
   }
+  else
+  {
+    DEBUG_printf(("1cupsDoAuthentication: Unknown auth type: \"%s\"",
+                  http->fields[HTTP_FIELD_WWW_AUTHENTICATE]));
+    http->status = HTTP_AUTHORIZATION_CANCELED;
+    return (-1);
+  }
 
   DEBUG_printf(("1cupsDoAuthentication: authstring=\"%s\"", http->authstring));
 
@@ -400,6 +259,114 @@ cupsDoAuthentication(
 
 #ifdef HAVE_GSSAPI
 /*
+ * '_cupsSetNegotiateAuthString()' - Set the Kerberos authentication string.
+ */
+
+int					/* O - 0 on success, -1 on error */
+_cupsSetNegotiateAuthString(
+    http_t *http)			/* I - Connection to server */
+{
+  OM_uint32	minor_status,		/* Minor status code */
+		major_status;		/* Major status code */
+  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
+				      /* Output token */
+  char		*gss_service_name;    /* GSS service name */
+
+
+#  ifdef __APPLE__
+ /*
+  * If the weak-linked GSSAPI/Kerberos library is not present, don't try
+  * to use it...
+  */
+
+  if (gss_init_sec_context == NULL)
+  {
+    DEBUG_puts("1_cupsSetNegotiateAuthString: Weak-linked GSSAPI/Kerberos "
+               "framework is not present");
+    return (-1);
+  }
+#  endif /* __APPLE__ */
+
+  if (http->gssname == GSS_C_NO_NAME)
+  {
+    if ((gss_service_name = getenv("CUPS_GSSSERVICENAME")) == NULL)
+      gss_service_name = CUPS_DEFAULT_GSSSERVICENAME;
+    else
+      DEBUG_puts("2_cupsSetNegotiateAuthString: GSS service name set via "
+		 "environment variable");
+
+    http->gssname = cups_get_gssname(http, gss_service_name);
+  }
+
+  if (http->gssctx != GSS_C_NO_CONTEXT)
+  {
+    gss_delete_sec_context(&minor_status, &http->gssctx, GSS_C_NO_BUFFER);
+    http->gssctx = GSS_C_NO_CONTEXT;
+  }
+
+  major_status  = gss_init_sec_context(&minor_status, GSS_C_NO_CREDENTIAL,
+				       &http->gssctx,
+				       http->gssname, http->gssmech,
+#ifdef GSS_C_DELEG_POLICY_FLAG
+				       GSS_C_DELEG_POLICY_FLAG |
+#endif /* GSS_C_DELEG_POLICY_FLAG */
+				       GSS_C_MUTUAL_FLAG | GSS_C_INTEG_FLAG,
+				       GSS_C_INDEFINITE,
+				       GSS_C_NO_CHANNEL_BINDINGS,
+				       GSS_C_NO_BUFFER, &http->gssmech,
+				       &output_token, NULL, NULL);
+
+  if (GSS_ERROR(major_status))
+  {
+    cups_gss_printf(major_status, minor_status,
+		    "_cupsSetNegotiateAuthString: Unable to initialize "
+		    "security context");
+    return (-1);
+  }
+
+  if (major_status == GSS_S_CONTINUE_NEEDED)
+    cups_gss_printf(major_status, minor_status,
+		    "_cupsSetNegotiateAuthString: Continuation needed!");
+
+  if (output_token.length > 0 && output_token.length <= 65536)
+  {
+   /*
+    * Allocate the authorization string since Windows KDCs can have
+    * arbitrarily large credentials...
+    */
+
+    int authsize = 10 +				/* "Negotiate " */
+		   output_token.length * 4 / 3 + 1 +	/* Base64 */
+		   1;					/* nul */
+
+    httpSetAuthString(http, NULL, NULL);
+
+    if ((http->authstring = malloc(authsize)) == NULL)
+    {
+      http->authstring = http->_authstring;
+      authsize         = sizeof(http->_authstring);
+    }
+
+    strcpy(http->authstring, "Negotiate ");
+    httpEncode64_2(http->authstring + 10, authsize - 10, output_token.value,
+		   output_token.length);
+
+    gss_release_buffer(&minor_status, &output_token);
+  }
+  else
+  {
+    DEBUG_printf(("1_cupsSetNegotiateAuthString: Kerberos credentials too "
+                  "large - %d bytes!", (int)output_token.length));
+    gss_release_buffer(&minor_status, &output_token);
+
+    return (-1);
+  }
+
+  return (0);
+}
+
+
+/*
  * 'cups_get_gssname()' - Get CUPS service credentials for authentication.
  */
 
diff -up cups-1.4.2/cups/globals.h.str3768 cups-1.4.2/cups/globals.h
--- cups-1.4.2/cups/globals.h.str3768	2014-03-06 12:11:48.983911126 +0000
+++ cups-1.4.2/cups/globals.h	2014-03-06 12:12:21.302071113 +0000
@@ -147,6 +147,9 @@ extern void		_cupsSetDefaults(void);
 extern void		_cupsSetError(ipp_status_t status, const char *message,
 			              int localize);
 extern void		_cupsSetHTTPError(http_status_t status);
+#  ifdef HAVE_GSSAPI
+extern int		_cupsSetNegotiateAuthString(http_t *http);
+#  endif /* HAVE_GSSAPI */
 extern char		*_cupsUserDefault(char *name, size_t namesize);
 
 
diff -up cups-1.4.2/cups/request.c.str3768 cups-1.4.2/cups/request.c
--- cups-1.4.2/cups/request.c.str3768	2009-08-29 07:05:14.000000000 +0100
+++ cups-1.4.2/cups/request.c	2014-03-06 12:12:21.302071113 +0000
@@ -613,10 +613,23 @@ cupsSendRequest(http_t     *http,	/* I -
     */
 
     httpClearFields(http);
-    httpSetLength(http, length);
+    httpSetExpect(http, expect);
     httpSetField(http, HTTP_FIELD_CONTENT_TYPE, "application/ipp");
+    httpSetLength(http, length);
+
+#ifdef HAVE_GSSAPI
+    if (http->authstring && !strncmp(http->authstring, "Negotiate", 9))
+    {
+     /*
+      * Do not use cached Kerberos credentials since they will look like a
+      * "replay" attack...
+      */
+
+      _cupsSetNegotiateAuthString(http);
+    }
+#endif /* HAVE_GSSAPI */
+
     httpSetField(http, HTTP_FIELD_AUTHORIZATION, http->authstring);
-    httpSetExpect(http, expect);
 
     DEBUG_printf(("2cupsSendRequest: authstring=\"%s\"", http->authstring));
 
